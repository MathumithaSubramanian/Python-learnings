# -*- coding: utf-8 -*-
"""python basics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1COcBX_uEZp9qWbhKLtorqdiQ3h8G4u7C
"""

# Variables:Container to store the value
a = 5
_b = 10.5
c1 = "value"
print(a)
print(c1,"is",_b)

# data types
a_string = "string data type"
a_int = 56
a_float = 5.8
a_list = ['string', 'data', 'type']
a_tuple = ('string', 'data', 'type')
a_dict = {'name' : 'mathu','age' : 20}
a_set = {'string', 'data', 'type'}
print(a_set)

# type casting
a_cast = float("5")
print(a_cast)

# string
# negative indexes to start the slice from the end of the string
a = "Slicing a string."
print(a[2:-7])

# operators
# Arithmetic [+, -, *, /, %(modulus), **(Exponeniation), //(Floor division)]
# Assignment [=, +=, -=, *=, /=, %=, **=, &=, >>=, <<=, |=]
# comparison [==, !=, <, >, >=, <=]
# Logical [and, or, not]
# Identity [is (Returns True if both variables are the same object), is not]
# Membership [in (Returns True if a sequence with the specified value is present in the object), not in]
# Bitwise [&(AND), |(OR), ^(XOR), ~(NOT)]

# List- list items are ordered, changeable, and allow duplicate values.
# Negative indexing means start from the end.
# Extend() method append elements from another list to the current list also tuples, set, dict.
# To delete the specified index..pop(1)...del list[1]...remove("name")
# Cpy of a list with the copy()...copylist = listofitems.copy()
# Append the list using..append(), +, extend()

listofitems = ["milk", "coffee powder", "sugar"]
print(listofitems[-1])
print(listofitems[1:])
listofitems.insert(3, "coffee")
print(listofitems)

# loop list
# [print(a) for a in listofitems]

for i in range(len(listofitems)):
    print("List", i, listofitems[i])
    
# List comprehension
newlist=[a for a in listofitems if "coffee" in a]
print(newlist)
        
# Sorting the list
listofitems.sort(reverse = True)
print("Desc order:", listofitems)

# Tuples..tuple is a collection which is ordered and unchangeable..it can be of any data type
# index() and count()
tuplelist = ('abc', 432, 'hjk')
print(tuplelist)

# set is a collection which is unordered, unchangeable*, and unindexed but we can remove items and add new items in the set.
# no duplicate values are allowed
# set contain different data types
# add items in the set...add(),update()[list,tuples,dict]
thisset = {'coldcoffee','sandwich'}
thisset.add('pizza')
print(thisset)

# To remove the items in the set...remove(),discard(),pop()[remove only the last item],clear()[to empty the set],del[delete the set completely]
thisset.remove('sandwich')
print(thisset)

# union() method returns a new set with all items from both sets
# update() method inserts the items in set2 into set1
set1 = {'b','f','t'}
set2 = {'3','r','6','b'}
set1.update(set2)
print(set1)

# intersection() method will return a new set, that only contains the items that are present in both sets.
# intersection_update() method will keep only the items that are present in both sets.
x = {'3', '6', '1'}
y = {'r', '6', 't'}
print(x.intersection(y))

# Dictionaries are used to store data values in key:value pairs
# It is ordered*, changeable and do not allow duplicates.It can be referred by using the key name.
mydict = {
  "name": "Jessi",
  "age": 22,
}
print(mydict["name"])
print(mydict.values())
print(mydict.items())

# change the value of a specific item using key.
mydict['age'] = 24
# add item in the dict using add(),update()
mydict.update({"lang":"tamil"})
# del item from the dict...pop(),popitem(),del(),clear()
mydict.pop("lang")
print(mydict)

# loop dict to print the keys and values alone
for x in mydict.items(): # keys(),values()
    print(x)

# If else conditonal statements
# Equals:a==b
# Not Equals: a!=b
# Less than: a < b
# Less than or equal to: a <= b
# Greater than: a > b
# Greater than or equal to: a >= b
a = 3
b = 8
if a > b:
    print("a is greater than b")
elif a == b:
    print("a equals to b")
else:
    print("b is greater than a")

# Function

def myfunc():
  print("Hello from a function")

myfunc()

# A parameter is the variable listed inside the parentheses in the function definition.
# An argument is the value that are sent to the function when it is called.

def myfunc(fname, lname):
  print(fname + " " + lname)

myfunc("christy", "Rohan")

# If you do not know how many arguments that will be passed into your function, add a * before the parameter(* args)

def myfunc(*kids):
  print("The youngest child is " + kids[2])

myfunc("Emil", "Tobias", "Linus")

# If you do not know how many keyword arguments that will be passed into your function, add two asterisk: ** (** kwargs)

def myfunc(**kid):
  print("His last name is " + kid["lname"])

myfunc(fname = "Tobias", lname = "Refsnes")

# function cannot be empty if so use the pass statement to avoid the errors

def myfunc():
  pass

# Classes and Objects
# The self parameter is a reference to the current instance of the class, and is used to access variables that belongs to the class

class Person:
  def __init__(self, name, age):
    self.name = name
    self.age = age

  def __str__(self):
    return f"{self.name}({self.age})"  
  
  def myfunc(self):
  	return self.name

p1 = Person("John", 36)

print(p1)
print(p1.myfunc())

# Inheritance - inherits all the methods and properties from another class
# Parent class is the class being inherited from, also called base class.
# Child class is the class that inherits from another class, also called derived class.

class Person:
  def __init__(self, fname, lname):
    self.firstname = fname
    self.lastname = lname

  def printname(self):
    print(self.firstname, self.lastname)

class Student(Person):
  def __init__(self, fname, lname, year):
    super().__init__(fname, lname)
    self.graduatefirstname= fname

x = Student("Mike", "Olsen", 2019)
print(x.graduatefirstname)